%% Language-Based Security project proposal template
%% 2022-02-07
%% To use this template:
%% - Remove \instruction commands and fill-in with your text
%% - Include your names in the author command
%%
%% - Compile with Makefile
%% - Edit literature.bib to include relevant literature.
%%
%% - Submit _only_ the resulting PDF file.
%%


\documentclass[10pt]{article}
\input{prelude}
\input{instructions}

\usepackage{mathpartir}
\usepackage{pftools}
\usepackage{tikz-cd}
\usetikzlibrary{cd}

% Notations
\newcommand{\pc}{\mathrm{pc}}
\newcommand{\lpc}{\mathrm{lpc}}
\newcommand{\ctx}{\Gamma}
\newcommand{\conf}{\sigma}
\newcommand{\public}{\mathrm{LPublic}}
\newcommand{\secret}{\mathrm{LSecret}}
\newcommand{\typing}[4]{ #1,~#2 \vdash #3 \rightsquigarrow #4}
\newcommand{\typingaux}[5]{ #1,~#2 \vdash #3 \rightsquigarrow #4,~#5}
\newcommand{\execaux}[7] { (#1,~#2,~#3) \xrightarrow{#4} (#5,~#6,~#7) }
% (config, Γ, lpc) - ev -> (config_f, Γf, lpcf)
\newcommand{\exec}[2] { #1 \rightarrow #2 }
\newcommand{\execn}[3] { #1 \rightarrow^{#2} #3 }
\newcommand{\bridge}[3] { #1 \curvearrowright_{#2} #3 }

\newcommand{\join}[2]{#1 \sqcup #2}
\newcommand{\joinc}[3][\pc]{#2 \sqcup #3}
\newcommand{\flowsto}[2]{#1 \sqsubseteq #2}
\newcommand{\etyping}[3]{ #1 \vdash #2 : #3}
\newcommand{\pini}[1]{\mathrm{PINI}(#1)}

% Environment
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\title{
   Flow-Sensitive Type System for PINI
}

\groupNumber{1}
\author{Maxime Legoupil \and Bastien Rousseau }

\begin{document}
\maketitle

\begin{abstract}
   Abstract of the project report: what, why PINI ? Type system for enforcement. Soundness.
\end{abstract}

\thispagestyle{empty}

\section{Introduction}
\label{sec:intro}
\instruction{ Write introduction }

Threat model: integrity, confidentiality, availability. For confidentiality, in a simple setup: 2
channels (public and private). We want to make sure that the secret data does not leak, both
directly (output a data tagged as secret on the public channel) or indirectly (event on the public
channel that happens in a control-flow depending on a secret input).
Side-channel such as timing-channel or cache-channel are out of scope.

Concept of non-interference, meaning that ``public outputs do not depend on secret inputs''.
Non-interference is a 2-hyperproperty, which means that it is a property that depends on 2
execution traces of the program. The way to prove that public outputs are independent from the
secret input is to run the same program 2 times, with the same public inputs, but different secret
input. If we notice a difference on the public output channel, only the secret input are responsible
(as the public ones are the same), and the not independent.

Different variant of non-interference: for instance, terminaison sensitive (TSNI), terminaison insensitive
(TINI).
Traditionally two way to enforce NI:
\begin{itemize}
  \item Monitor, that \emph{dynamically} check the public output channel that it does not leak
        values tagged as secret.
  \item Type system, which ensure \emph{statically} that a well-typed program respects NI.
\end{itemize}

\instruction{ Do we detail more the two approaches ? I don't think that it is necessary }

In this work, we focus in a variant of NI, called Progress-Insensitive-Non-Interference (PINI).
Interesting because \instruction{ complete }.
We develop a flow-sensitive type-system that enforce PINI, ie. all well-typed program respects PINI.
We prove that the type system is sound.

In the following report, we first introduce the operational semantic of the language in
Section~\ref{subsec:opsem} that we consider.
We then formally define our notion of non-interference Section~\ref{subsec:ni}, as well as the type
system to enforce it Section~\ref{subsec:type_system}.
Finally, we detail the soundness theorem and its proof in Section~\ref{sec:soundness}.

This work is formalized in the Coq Proof Assistant.

\section{Blabla}
\label{sec:bla}
\instruction{ Fill the section }

\subsection{WHILE language with I/O}%
\label{subsec:opsem}

The language is a simple WHILE language with I/O.
\instruction{ Figure syntax }
\instruction{ Figure operational semantic }

\subsection{Non-interference}%
\label{subsec:ni}

Non-interference: ``public outputs do not depend on secret inputs''.
Knowledge of the attacker: what does an attacker learn from a public event.
Given a public trace, public input and program, the attacker knowledge is the set of secret inputs
that the attacker that are consistent with the trace of execution.

Progress-sensitive: public events does not give more knowledge to the attacker. In other words,
at any step, the knowledge of the attacker is the same (it cannot narrow down the set of possible
secret input).

Intuition ? Might be hard to enforce (why ?).

Because PSNI is hard to enforce, we define Progress-Insensitive (PINI).

Progress-knowledge:
Given a public trace, public input and program, the attacker knowledge is the set of secret inputs
that the attacker that are consistent with the trace of execution, if learning one more public
event.
Progress-insensitive: the attacker does not learn more by knowing the next public event.

Intuition ? Why easier to enforce ?
The attacker already knows in advance that there will be another event, but it doesn't know which
one precisely. Knowing what the event is exactly does not give more knowledge.

\subsection{Type system}%
\label{subsec:type_system}

We define a type system that enforce PINI.
The type system is flow sensitive.
\instruction{ What does flow sensitive means ? }.

\instruction{ What can we say that is interesting about the type system ? }.

For expressions, just like before, \( \etyping{\ctx}{e}{\ell} \) means that expression \( e \) has
confidentiality level \( \ell \) in context \( \ctx \):

\input{figures/typing_expr.tex}

For commands, \( \typing{\ctx}{\pc}{c}{\ctx'} \) means that in context \( \ctx \) and execution
level \( \pc \), command \( c \) is safe to execute and after execution, the context is now
\( \ctx' \).

\input{figures/typing_cmd.tex}

\instruction{Explain while rule}

\section{Soundness}%
\label{sec:soundness}

The soundness theorem states that the type system actually enforce PINI. In other words, it formally
states that any well-typed program is PINI.

\instruction{ Fill the section depending on the approach }

\subsection{Approach}%
\label{subsec:approach}

In order to prove the theorem, we follow a similar approach than the one in (information flow
lecture notes).

First, we define an auxiliary, augmented language, that explicitly specify when we reach a join
point. Then, the we define the auxiliary semantic, that keep track of the type with the typing
environment and the current security level.

Then, we show that this auxiliary language is somewhat equivalent to the original language, in the
sense that there is a correspondence between them. As such, we can reason on the auxiliary language,
and reflect the result on the original one with an adequacy theorem.

Finally, the main proof remains on a bridge relation, that allows to reason precisely on the
transitions that emits a public event.

\subsection{Auxiliary language}%
\label{subsec:aux_lang}

% Syntax and opsem
The syntax of the auxiliary language is similar to the WHILE language, but adds the following
command explicit \emph{join}.

\[ \mathit{cmd}~::=~\cdots~|~\mathrm{Join} \]

The Join needs to be explicit in order to reason about the security level of the pc when leaving a
if-then-else branch.

The operational semantic carries along the typing context, which associate a security level to the
variables in the memory and to the pc. In order to reason about the join points, we need to remember
the history of the previous pc: as such, the pc is actually a list security labels, where the head
is the current security level.

The relation \(\execaux{\conf}{\ctx}{\lpc}{\alpha}{\conf_{f}}{\ctx_{f}}{\lpc_{f}} \)
states that the configuration $\conf$, with the typing context $\ctx$, at the current security level
$\lpc$ steps to the configuration $\conf_{f}$, with the new typing context $\ctx_{f}$ and the new
security level $\lpc_{f}$, and emits the event $\alpha$. The emitted event can be empty.

\instruction{figure opsem auxiliary}

The main feature of the operational semantic is the management of the pc:
at every conditional branch, the history is incremented with the security label of the condition
expression to the pc.
When reaching a Join instruction, the last pc in the history is poped. If the history is empty, then
the pc is public.

Moreover, the language of event is enriched with a $Write$ event, that is emitted at every
assignment of a public expression. We need to enrich the events because we need to keep track of the
modifications in memory.
% Because of the agree on memory

\instruction{
  In the Coq development, the Join takes a command as an argument. In the operational semantic,
  $\mathrm{Join}\ c$ reduces to $c$, while it reduces to $\mathrm{Skip}$ in this case. The reason is
  that it simplifies the adequacy theorem, as there is a one-to-one correspondence between each
  steps. In fine, the two definition are equivalent.
}

% We define the reflexive and transitive cloture of the relation, which records the trace of the
% events.

We also define a typing judgment for the auxiliary language, which refines the typing judgment of
the original language.
First, the typing judgment also capture the pc after the execution of the command. Then, as the pc
is now an history of pc, all conditions over the pc takes the join of the history.
\instruction{reformulate the previous sentence}

The typing system is also extended a rule for the join, which captures the fact that a Join leaves
the current security level by removing the head pc of the history.

\[
    \inferH{Join}
    {\typingaux{\ctx}{\lpc}{c}{\ctx'}{\pc::\lpc'}}
    {\typingaux{\ctx}{\lpc}{\mathrm{Join}~c}{\ctx'}{\lpc'}}
\]


The auxiliary language and type-system enjoy some interesting properties.

% Preservation
The preservation lemma states that if a well-typed term takes a step, then the resulting term is
well-typed, under the (potentially) new typing context.

\begin{lemma}[Preservation]
  Let $\conf \triangleq (c,~S,~P,~m,~\tau)$ and
  $\conf' \triangleq (c',~S',~P',~m',~\tau')$ be configurations.
  Let further suppose:
  \begin{itemize}
    \item $m$ be well-formed memory wrt. $\ctx$
    \item $\typingaux{\ctx}{\lpc}{c}{\ctx_{f}}{\lpc_{f}}$
    \item \( \execaux{\conf}{\ctx}{\lpc}{\alpha}{\conf'}{\ctx'}{\lpc'} \)
  \end{itemize}

  Then, $m'$ is well-formed wrt. $\ctx'$, and the command $c'$ is also well-typed
  $\typingaux{\ctx'}{\lpc'}{c'}{\ctx_{f}}{\lpc_{f}}$.
\end{lemma}

% Adequacy wrt. the WHILE language
In order to establishes an equivalence between the original language and the auxiliary language, we
define a transformation from the auxiliary language to the original language, which consists on
erasing the join command; and a transformation from the original language to the original language,
which consists on adding the join command after every if-then-else.

The equivalence between the two languages are reflected via the two following adequacy theorems:

\begin{lemma}[Adequacy auxiliary typing]
  For any $\ctx$, $\pc$, $c$ and $\ctx_{f}$,
  \[
  \typing{\ctx}{\pc}{c}{\ctx_{f}}
  \Leftrightarrow
    \typingaux{\ctx}{\lpc}{c}{\ctx_{f}}{\lpc}
  \]

  where $\pc$ is lifted to $\lpc$.
\end{lemma}

The adequacy of the auxiliary typing establishes that the transformation from one language to
another preserves the typing judgment for the corresponding language.

\begin{lemma}[Adequacy auxiliary language]
  Let $\conf \triangleq (c,~S,~P,~m,~\tau)$ and
  $\conf' \triangleq (c',~S',~P',~m',~\tau')$ be configurations.
  Let suppose:
  \begin{itemize}
    \item $m$ be well-formed memory wrt. $\ctx$
    \item $\typing{\ctx}{\pc}{c}{\ctx_{f}}$
    \item $\conf$ steps to $\conf'$
  \end{itemize}

  Then, it exists $j'$, $\ctx'$, $\lpc'$ and $\alpha$ such that

  \( \execaux{\conf}{\ctx}{\lpc}{\alpha}{\conf'}{\ctx'}{\lpc'} \),

  where $\pc$ is lifted to $\lpc$, the configuration $\conf$ uses the transformation of the command,
  and the resulting command $j'$ of configuration $\conf'$ is the transformation of the command $c'$.
\end{lemma}

The adequacy of the auxiliary language establishes that, if the memory is well-formed, the
command is well-typed in the original language, and takes a step, then we can also take a similar
step in the auxiliary language.

In the following diagram, the adequacy lemma states that $j'$ is the compilation of $c'$:
\begin{tikzcd}
compile(c) \arrow[r]  & j'                   \\
c \arrow[u] \arrow[r] & c' \arrow[u, dashed]
\end{tikzcd}

\instruction{transition}

\subsection{Bridge relations}%
\label{subsec:brigde_rel}

\instruction{ bridge relation defined on the auxiliary language }

Basic bridge relation (in the Coq development, named \emph{bridge})
: two states basic-bridge in n steps, if they take n-1 steps without emitting any public
event, and then take any public event.

Write-bridge relation (in the Coq development, named \emph{write-bridge})
: two states write-bridge in n steps, if they take n-1 steps without emitting
any public event, and then take a write public event.

Silent-bridge relation (in the Coq development, named \emph{silent-bridge})
: two states silent-bridge in n steps, if they take n steps without emitting
any public event.

We define the transitive closure for the different bridge relations. In particular, basic-bridge and
write-bridge are not reflexive, as they impose at least one step emitting a public event.

The bridge relation (in the Coq development, named \emph{full-bridges}) is our main relation. There
is two different ways for two states to bridge: first,
the starting state takes any number of basic-bridge, then it takes one basic-bridge that do not emit
a write-event, then any number of write-bridge, and finally any number of silent-bridges ; the second
way is to take any number of write-bridge, and then any number of silent-bridges.

Figure~\ref{fig:bridge_relation} shows these two different ways to bridge, where $b$ stands for
basic-bridge, $bnw$ for basic-bridge non-write, $wb$ for write-bridge and $sb$ for silent-bridge.
The adequacy allows one to move from the original language to the auxiliary one, and the other way around.

% Motivation for all the relations
The different bridge relations allows us to decompose any pack of steps by the kind of events, and
to know precisely what is synchronized or not each time.
\instruction{a bit more motivations: the first path actually change the trace, while the 2nd one not
really, as it only perform public writes}

We can derive two main theorems: an adequacy theorem and an agreement theorem.
\begin{theorem}[Bridge adequacy]
  Let $\conf \triangleq (c,~S,~P,~\tau)$ and $\conf' \triangleq (c',~S',~P',~\tau')$ be two
  configurations of the original language, an initial and final contexts $\ctx$ and $\ctx'$, and an
  initial pc $\pc$.
  Let further suppose that

 \begin{itemize}
   \item $m$ be a well-formed memory wrt. $\ctx$,
   \item \(\typing{\ctx}{\pc}{c}{\ctx'} \)
   \item \( \execn{\conf}{n}{\conf'} \)
 \end{itemize}

  Then, it exists $j$ and $\tau_{f}$ \( \bridge{c}{\tau}{j} \) such that $c' = compile(j)$ and $\tau_{f} \setminus \mathrm{Write} = \tau'$.
\end{theorem}

\instruction{I'm not happy with this explanation, find a better formulation}
In other words, the \emph{bridge adequacy} theorem states that if a command is well-type, and takes
any number of steps, then its auxiliary counterpart bridges to a state that is the compilation of
the final state and that record exactly the public trace.

This theorem then allows to reason on the bridge relation rather than on the operational semantic.
\instruction{Why is it good ? Because the bridge relation decompose the steps by looking only at the
  emitted public events, and give more information about what part is synchronized or not}
Figure~\ref{fig:bridge_relation} shows draws the adequacy.

\input{figures/bridge_relation.tex}


\begin{theorem}[Bridge agree]
  We start with two configurations that agree on publics, a command that that is well typed, two
  final traces that have the same length on the publics event, and bridges (first part).

  Then the final command is the same, the final memory agree on publics, and the emitted events are
  the same.
\end{theorem}

\instruction{Where is defined memory agree on public ? }

The theorem is split in 3 lemmas: basic-bridge, write-bridge and silent-bridge agree.

Silent-bridge agree states that in-between two silent bridge of two executions,
the memory agree on public, public input are the same and the public
traces are the same for both execution. It holds because silent-bridge relates states that do not
emit any public events: the traces don't change, and the public part of the memory don't change
either.

Write-bridge agree states that in-between two write-bridges of two executions,
the public traces are the same for both execution. It holds because write-bridge relates states that
do not emit only write-events, which means that memories might not agree on the public anymore, but
they do not emit any visible events in the trace.

Basic-bridge is the main lemma: it states that in-between two basic-bridges of two executions of
same length, the final command is the same, the final memory agree on publics, and
public traces are the same for both execution.
It holds because \instruction{fill in}.

\subsection{Main theorem}%
\label{subsec:main_theorem}

\begin{theorem}[Soundness type-system]
  \( \forall c, \ctx.\
  \typing{\emptyset}{\mathrm{Public}}{c}{\ctx}
  \Rightarrow \pini{c}
  \)
\end{theorem}

Composition of the lemma that leads to the soundness theorem.

\section{Conclusion}%
\label{sec:conclusion}

We have defined a type-system for PINI. Mechanized the proof of soundness in Coq.
What next ?


%% References
%% - Edit literature.bib to add references
%%
\bibliographystyle{abbrvnat}
\bibliography{literature}

\end{document}
