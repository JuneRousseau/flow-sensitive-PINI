%% Language-Based Security project proposal template
%% 2022-02-07
%% To use this template:
%% - Remove \instruction commands and fill-in with your text
%% - Include your names in the author command
%%
%% - Compile with Makefile
%% - Edit literature.bib to include relevant literature.
%%
%% - Submit _only_ the resulting PDF file.
%%


\documentclass[10pt]{article}
\input{prelude}
\input{instructions}

\usepackage{mathpartir}
\usepackage{pftools}
\usepackage{stmaryrd}

\usepackage{tikz-cd}
\usetikzlibrary{cd}

% Notations
\newcommand{\pc}{\mathrm{pc}}
\newcommand{\lpc}{\mathrm{lpc}}
\newcommand{\ctx}{\Gamma}
\newcommand{\conf}{\sigma}
\newcommand{\public}{\mathrm{LPublic}}
\newcommand{\secret}{\mathrm{LSecret}}
\newcommand{\typing}[4]{ #1,~#2 \vdash #3 \rightsquigarrow #4}
\newcommand{\typingaux}[5]{ #1,~#2 \vdash #3 \rightsquigarrow #4,~#5}
\newcommand{\execaux}[7] { (#1,~#2,~#3) \xrightarrow{#4} (#5,~#6,~#7) }
% (config, Γ, lpc) - ev -> (config_f, Γf, lpcf)
\newcommand{\exec}[2] { #1 \rightarrow #2 }
\newcommand{\execn}[3] { #1 \rightarrow^{#2} #3 }
\newcommand{\bridge}[3] { #1 \curvearrowright_{#2} #3 }
\newcommand{\whilelang}{\textsc{While Lang} }
\newcommand{\pproj}[1]{\llbracket #1 \rrbracket_{p}}

\newcommand{\join}[2]{#1 \sqcup #2}
\newcommand{\joinc}[3][\pc]{#2 \sqcup #3}
\newcommand{\flowsto}[2]{#1 \sqsubseteq #2}
\newcommand{\etyping}[3]{ #1 \vdash #2 : #3}
\newcommand{\pini}[1]{\mathrm{PINI}(#1)}

% Environment
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\title{
   Flow-Sensitive Type System for PINI
}

\groupNumber{1}
\author{Maxime Legoupil \and Bastien Rousseau }

\begin{document}
\maketitle

% \begin{abstract}
%    Abstract of the project report: what, why PINI ? Type system for enforcement. Soundness.
% \end{abstract}

\thispagestyle{empty}

\section{Introduction}
\label{sec:intro}

In a computer system, the security policies define what kind of properties are desired on the
system. The main policies are integrity, confidentiality and availability.
The security mechanisms are the implementation of a specific method to enforce the security policy,
against a specific threat model, ie.\ the power given to an attacker.

In the case of confidentiality, the system wants some data to be secret. An attacker thus should not
be able to read, or get any information these data. We consider a simple setup, a programming
language with I/O primitives, communicating with two kind of I/O channels: public and secret
channels.
The security policy that we want to ensure is the confidentiality of the secret inputs. We
want to make sure that the secret data does not leak. To enforce the confidentiality, we define a
type-system.
The threat model is that an attacker can write any program well-typed, and observe the public
channels. Side-channel such as timing-channel or cache-channel are out of scope.

In our security model, the assurance that the type-system enforce confidentiality is by a formal
proof. The first step is to formally define what \emph{confidentiality} means. A widely used
definition of confidentiality is called \emph{non-interference}. In a high-level way,
non-interference means that ``public outputs do not depend on secret inputs''.
Non-interference is a 2-hyperproperty, which means that it is a property that depends on 2
execution traces of the program. The way to prove that public outputs are independent from the
secret input is to run the same program 2 times, with the same public inputs, but different secret
input. If we notice a difference on the public output channel, only the secret input are responsible
(as the public ones are the same in both execution).

Non-interference (NI) is actually a class of properties for which it exists different variants. For
instance, we can cite \emph{Termination Sensitive NI} (TSNI) or \emph{Termination Insensitive NI}
(TINI). The latter allows an adversary to differentiate a secret with the non-termination of the
program, while the former does not.

There are traditionally two way to enforce non-interference:
\begin{itemize}
  \item monitor based: \emph{dynamically} checks that the public output channel does not leak values
        tagged as secret
  \item type-system based: \emph{statically} ensures that a well-typed program respects NI
\end{itemize}
\instruction{ Do we detail more the two approaches ? I don't think that it is necessary }

In this work, we focus in a variant of NI called \emph{Progress-Insensitive Non-Interference}
(PINI).
Intuitively, PINI ensures that, if the adversary knows that there will be at least one more public
event, it cannot gain any knowledge on the secret by learning what this event actually is. PINI is
interesting, as we can see it as a variant of TINI with intermediate I/O.
We develop a flow-sensitive type-system that enforce PINI, ie. all well-typed program respects PINI,
and we prove that the type system is sound.

In the following report, we first introduce in
Section~\ref{subsec:opsem} the language that we consider, and its operational semantic.
We then formally define in Section~\ref{subsec:ni} the notion of Progress-Insensitive
Non-Interference, and Section~\ref{subsec:type_system} presents the type-system that enforces it.
Finally, we detail the soundness theorem and its proof in Section~\ref{sec:soundness}.

This work is formalized in the Coq Proof Assistant, available in a
\href{https://github.com/BastienRousseau/flow-sensitive-PINI}{Github repository}.
The proof is not complete, we then develop the limits of our implementation and the difficulties
that we encountered in Section~\ref{sec:conclusion}.

\section{Formalization}
\label{sec:formalization}
In this section, we formally introduce the \whilelang, the non-interference property and the
type-system.

\subsection{\whilelang}%
\label{subsec:opsem}

\whilelang is a simple WHILE language with input and output primitives. Figure~\ref{fig:lang_syntax}
shows the syntax of the language.

A configuration is a tuple $\conf \triangleq (c,~S,~P,~m,~\tau)$, where $c$ is a command, $S$ and
$P$ are the stream of respectively the secret and public inputs, $m$ is the memory (a partial map
from variables to values) and $\tau$ is the trace of events emitted so far.
For the sake of the presentation, we might use $c$ and $\conf$ interchangeably when it is clear from
the context.

Figure~\ref{fig:lang_opsem} shows the operational semantic of the language. The operational semantic
is pretty standard, so we will not \instruction{linger too long on} the explanations.

\instruction{ Figure syntax }
\instruction{ Figure operational semantic }

\subsection{Non-interference}%
\label{subsec:ni}

The mantra of non-interference is that ``public outputs do not depend on secret inputs''.
We will define formally this concept using the notion of \emph{attacker knowledge}. The attacker
knowledge is the ability for an adversary to deduce the possible secret inputs. It defines what can
an attacker learn by looking at the public outputs.
More precisely, the attacker knowledge is the set of secret inputs that are consistent with the
public execution trace. Thus, smaller is the set of possible inputs, bigger is the attacker
knowledge.

Formally, the attacker knowledge $K$ is defined by
\[
  K(P,~c,~\delta) \triangleq
  \{ S ~|~ \exists \conf'.\
  \exec{(c,~S,~P,~m_{\mathrm{init}},~\varepsilon)}{\conf'}
  \wedge
  \pproj{\tau'} = \delta
  \}
\]
where $\pproj{\tau}$ is the projection of the public events of the trace $\tau$.

Using this base definition, we can define a variant of NI called \emph{Progress Sensitive
  Non-Interference} (PSNI).
\[
  \mathrm{PSNI} \triangleq
  \forall P,c,\delta,\alpha. \ K(P,~c,~\alpha::\delta) = K(P,~c,~\delta)
\]
The intuition is that, if the adversary has already discover the public trace $\delta$ by the
execution, discovering a new public event $\alpha$ does not provide more knowledge.
In other words, at any step of computation, the knowledge of the attacker is the same, and it cannot
narrow down the set of possible secret inputs.
However, PSNI is hard to enforce. \instruction{why ? because we need to know whether there will be a
  future event}

Because PSNI is hard to enforce, we define the \emph{Progress Insensitive Non-Interference} (PINI)
variant. Intuitively, we allow the adversary to know that there will be a future public event, but
when it indeed learn the exact event, it does change its knowledge. In order to formally define this
intuition, we first define the notion of \emph{progress knowledge} $K_{\rightarrow}$, which is a
variant of the attacker knowledge \instruction{with an additional (any) public event}.
\[
  K_{\rightarrow}(P,~c,~\delta) \triangleq
  \{ S ~|~ \exists \conf',\alpha.\
  \exec{(c,~S,~P,~m_{\mathrm{init}},~\varepsilon)}{\conf'}
  \wedge
  \pproj{\tau'} = \alpha::\delta
  \}
\]
The progress knowledge captures the set of secret input that are consistent with the execution $c$,
the already known public trace $\delta$ and any additional public event $\alpha$.
We can thus formally define PINI:
\[
  \mathrm{PINI} \triangleq
  \forall P,c,\delta,\alpha. \ K(P,~c,~\alpha::\delta) = K_{\rightarrow}(P,~c,~\delta)
\]
which indeed capture the fact that learning an additional event does not give more knowledge than
knowing that a public event will arrive.
PINI is easier to enforce than PSNI, because the attacker already knows in advance that there will
be another event, but it doesn't know which one precisely.

\subsection{Type system}%
\label{subsec:type_system}

We define a type system that enforce PINI.
The type system is flow sensitive.
\instruction{ What does flow sensitive means ? }.

\instruction{ What can we say that is interesting about the type system ? }.

For expressions, just like before, \( \etyping{\ctx}{e}{\ell} \) means that expression \( e \) has
confidentiality level \( \ell \) in context \( \ctx \):

\input{figures/typing_expr.tex}

For commands, \( \typing{\ctx}{\pc}{c}{\ctx'} \) means that in context \( \ctx \) and execution
level \( \pc \), command \( c \) is safe to execute and after execution, the context is now
\( \ctx' \).

\input{figures/typing_cmd.tex}

\instruction{Explain while rule}

\section{Soundness}%
\label{sec:soundness}

The soundness theorem states that the type system actually enforce PINI. In other words, it formally
states that any well-typed program is PINI.

\instruction{ Fill the section depending on the approach }

\subsection{Approach}%
\label{subsec:approach}

In order to prove the theorem, we follow a similar approach than the one in (information flow
lecture notes).

First, we define an auxiliary, augmented language, that explicitly specify when we reach a join
point. Then, the we define the auxiliary semantic, that keep track of the type with the typing
environment and the current security level.

Then, we show that this auxiliary language is somewhat equivalent to the original language, in the
sense that there is a correspondence between them. As such, we can reason on the auxiliary language,
and reflect the result on the original one with an adequacy theorem.

Finally, the main proof remains on a bridge relation, that allows to reason precisely on the
transitions that emits a public event.

\subsection{Auxiliary language}%
\label{subsec:aux_lang}

% Syntax and opsem
The syntax of the auxiliary language is similar to the WHILE language, but adds the following
command explicit \emph{join}.

\[ \mathit{cmd}~::=~\cdots~|~\mathrm{Join} \]

The Join needs to be explicit in order to reason about the security level of the pc when leaving a
if-then-else branch.

The operational semantic carries along the typing context, which associate a security level to the
variables in the memory and to the pc. In order to reason about the join points, we need to remember
the history of the previous pc: as such, the pc is actually a list security labels, where the head
is the current security level.

The relation \(\execaux{\conf}{\ctx}{\lpc}{\alpha}{\conf_{f}}{\ctx_{f}}{\lpc_{f}} \)
states that the configuration $\conf$, with the typing context $\ctx$, at the current security level
$\lpc$ steps to the configuration $\conf_{f}$, with the new typing context $\ctx_{f}$ and the new
security level $\lpc_{f}$, and emits the event $\alpha$. The emitted event can be empty.

\instruction{figure opsem auxiliary}

The main feature of the operational semantic is the management of the pc:
at every conditional branch, the history is incremented with the security label of the condition
expression to the pc.
When reaching a Join instruction, the last pc in the history is poped. If the history is empty, then
the pc is public.

Moreover, the language of event is enriched with a $Write$ event, that is emitted at every
assignment of a public expression. We need to enrich the events because we need to keep track of the
modifications in memory.
% Because of the agree on memory

\instruction{
  In the Coq development, the Join takes a command as an argument. In the operational semantic,
  $\mathrm{Join}\ c$ reduces to $c$, while it reduces to $\mathrm{Skip}$ in this case. The reason is
  that it simplifies the adequacy theorem, as there is a one-to-one correspondence between each
  steps. In fine, the two definition are equivalent.
}

% We define the reflexive and transitive cloture of the relation, which records the trace of the
% events.

We also define a typing judgment for the auxiliary language, which refines the typing judgment of
the original language.
First, the typing judgment also capture the pc after the execution of the command. Then, as the pc
is now an history of pc, all conditions over the pc takes the join of the history.
\instruction{reformulate the previous sentence}

The typing system is also extended a rule for the join, which captures the fact that a Join leaves
the current security level by removing the head pc of the history.

\[
    \inferH{Join}
    {\typingaux{\ctx}{\lpc}{c}{\ctx'}{\pc::\lpc'}}
    {\typingaux{\ctx}{\lpc}{\mathrm{Join}~c}{\ctx'}{\lpc'}}
\]


The auxiliary language and type-system enjoy some interesting properties.

% Preservation
The preservation lemma states that if a well-typed term takes a step, then the resulting term is
well-typed, under the (potentially) new typing context.

\begin{lemma}[Preservation]
  Let $\conf \triangleq (c,~S,~P,~m,~\tau)$ and
  $\conf' \triangleq (c',~S',~P',~m',~\tau')$ be configurations.
  Let further suppose:
  \begin{itemize}
    \item $m$ be well-formed memory wrt. $\ctx$
    \item $\typingaux{\ctx}{\lpc}{c}{\ctx_{f}}{\lpc_{f}}$
    \item \( \execaux{\conf}{\ctx}{\lpc}{\alpha}{\conf'}{\ctx'}{\lpc'} \)
  \end{itemize}

  Then, $m'$ is well-formed wrt. $\ctx'$, and the command $c'$ is also well-typed
  $\typingaux{\ctx'}{\lpc'}{c'}{\ctx_{f}}{\lpc_{f}}$.
\end{lemma}

% Adequacy wrt. the WHILE language
In order to establishes an equivalence between the original language and the auxiliary language, we
define a transformation from the auxiliary language to the original language, which consists on
erasing the join command; and a transformation from the original language to the original language,
which consists on adding the join command after every if-then-else.

The equivalence between the two languages are reflected via the two following adequacy theorems:

\begin{lemma}[Adequacy auxiliary typing]
  For any $\ctx$, $\pc$, $c$ and $\ctx_{f}$,
  \[
  \typing{\ctx}{\pc}{c}{\ctx_{f}}
  \Leftrightarrow
    \typingaux{\ctx}{\lpc}{c}{\ctx_{f}}{\lpc}
  \]

  where $\pc$ is lifted to $\lpc$.
\end{lemma}

The adequacy of the auxiliary typing establishes that the transformation from one language to
another preserves the typing judgment for the corresponding language.

\begin{lemma}[Adequacy auxiliary language]
  Let $\conf \triangleq (c,~S,~P,~m,~\tau)$ and
  $\conf' \triangleq (c',~S',~P',~m',~\tau')$ be configurations.
  Let suppose:
  \begin{itemize}
    \item $m$ be well-formed memory wrt. $\ctx$
    \item $\typing{\ctx}{\pc}{c}{\ctx_{f}}$
    \item $\conf$ steps to $\conf'$
  \end{itemize}

  Then, it exists $j'$, $\ctx'$, $\lpc'$ and $\alpha$ such that

  \( \execaux{\conf}{\ctx}{\lpc}{\alpha}{\conf'}{\ctx'}{\lpc'} \),

  where $\pc$ is lifted to $\lpc$, the configuration $\conf$ uses the transformation of the command,
  and the resulting command $j'$ of configuration $\conf'$ is the transformation of the command $c'$.
\end{lemma}

The adequacy of the auxiliary language establishes that, if the memory is well-formed, the
command is well-typed in the original language, and takes a step, then we can also take a similar
step in the auxiliary language.

In the following diagram, the adequacy lemma states that $j'$ is the compilation of $c'$:
\begin{tikzcd}
compile(c) \arrow[r]  & j'                   \\
c \arrow[u] \arrow[r] & c' \arrow[u, dashed]
\end{tikzcd}

\instruction{transition}

\subsection{Bridge relations}%
\label{subsec:brigde_rel}

\instruction{ bridge relation defined on the auxiliary language }

We define multiple kind of bridge relations, that relates two states in different ways:

\begin{itemize}
  \item Basic-bridge relation (\emph{basic\_bridge} in the Coq development):
        two states basic-bridge in n steps, if they take n-1 steps without emitting any public
        event, and then take any public event.
  \item Write-bridge relation (\emph{write\_bridge} in the Coq development):
        two states write-bridge in n steps, if they take n-1 steps without emitting any public
        event, and then take a write public event.
  \item Silent-bridge relation (\emph{silent\_bridge} in the Coq development):
        two states silent-bridge in n steps, if they take n steps without emitting
\end{itemize}

We define the transitive closure for the write-bridge relation. One may notice that it cannot be
reflexive, as it imposes at least one step emitting a write event.

The bridge relation (in the Coq development, named \emph{bridge}) is our main relation. There
is two different ways for two states to bridge: first,
the starting state takes any number of basic-bridges, then it takes one basic-bridge that do not emit
a write-event, then any number of write-bridge, and finally any number of silent-bridges; the second
way is to take any number of write-bridge, and then any number of silent-bridges.

Figure~\ref{fig:bridge_relation} shows these two different ways to bridge, where $b$ stands for
basic-bridge, $bnw$ for basic-bridge non-write, $wb$ for write-bridge and $sb$ for silent-bridge.
The adequacy allows one to move from the original language to the auxiliary one, and the other way around.

% Motivation for all the relations
The different bridge relations allows us to decompose any pack of steps by the kind of events, and
to know precisely what is synchronized or not each time.
\instruction{a bit more motivations: the first path actually change the trace, while the 2nd one not
really, as it only perform public writes}

We can derive two main theorems: an adequacy theorem and an agreement theorem.
\begin{theorem}[Bridge adequacy]
  Let $\conf \triangleq (c,~S,~P,~\tau)$ and $\conf' \triangleq (c',~S',~P',~\tau')$ be two
  configurations of the original language, an initial and final contexts $\ctx$ and $\ctx'$, and an
  initial pc $\pc$.
  Let further suppose that

 \begin{itemize}
   \item $m$ be a well-formed memory wrt. $\ctx$,
   \item \(\typing{\ctx}{\pc}{c}{\ctx'} \)
   \item \( \execn{\conf}{n}{\conf'} \)
 \end{itemize}

  Then, it exists $j$ and $\tau_{f}$ \( \bridge{c}{\tau}{j} \) such that $c' = compile(j)$ and $\tau_{f} \setminus \mathrm{Write} = \tau'$.
\end{theorem}

\instruction{I'm not happy with this explanation, find a better formulation}
In other words, the \emph{bridge adequacy} theorem states that if a command is well-type, and takes
any number of steps, then its auxiliary counterpart bridges to a state that is the compilation of
the final state and that record exactly the public trace.

This theorem then allows to reason on the bridge relation rather than on the operational semantic.
\instruction{Why is it good ? Because the bridge relation decompose the steps by looking only at the
  emitted public events, and give more information about what part is synchronized or not}
Figure~\ref{fig:bridge_relation} shows draws the adequacy.

\input{figures/bridge_relation.tex}


\begin{theorem}[Bridge agree]
  We start with two configurations that agree on publics, a command that that is well typed, two
  final traces that have the same length on the publics event, and bridges (first part).

  Then the final command is the same, the final memory agree on publics, and the emitted events are
  the same.
\end{theorem}

\instruction{Where is defined memory agree on public ? }

The theorem is split in 3 lemmas: basic-bridge, write-bridge and silent-bridge agree.

Silent-bridge agree states that in-between two silent bridge of two executions,
the memory agree on public, public input are the same and the public
traces are the same for both execution. It holds because silent-bridge relates states that do not
emit any public events: the traces don't change, and the public part of the memory don't change
either.

Write-bridge agree states that in-between two write-bridges of two executions,
the public traces are the same for both execution. It holds because write-bridge relates states that
do not emit only write-events, which means that memories might not agree on the public anymore, but
they do not emit any visible events in the trace.

Basic-bridge is the main lemma: it states that in-between two basic-bridges of two executions of
same length, the final command is the same, the final memory agree on publics, and
public traces are the same for both execution.
It holds because \instruction{fill in}.

\instruction{overview of the proofs ? especially why/where do we need the previous lemmas ? }

\subsection{Main theorem}%
\label{subsec:main_theorem}

\begin{theorem}[Soundness type-system]
  \( \forall c, \ctx.\
  \typing{\emptyset}{\mathrm{Public}}{c}{\ctx}
  \Rightarrow \pini{c}
  \)
\end{theorem}

Composition of the lemma that leads to the soundness theorem.

\section{Limits and conclusion}%
\label{sec:conclusion}

We have defined a type-system for PINI. Mechanized the proof of soundness in Coq.
What next ?


%% References
%% - Edit literature.bib to add references
%%
\bibliographystyle{abbrvnat}
\bibliography{literature}

\end{document}
